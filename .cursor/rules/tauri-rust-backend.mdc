---
description: Tauri Rust Backend Development Guide
globs: 
alwaysApply: false
---
# Tauri Rust Backend Development Guide

## Backend Architecture
The Rust backend handles native functionality, data persistence, and system integration for the memos client app.

## Project Structure

### Core Files
- **Main Entry**: [src-tauri/src/main.rs](mdc:src-tauri/src/main.rs) - Application entry point
- **Library**: [src-tauri/src/lib.rs](mdc:src-tauri/src/lib.rs) - Tauri commands and business logic
- **Configuration**: [src-tauri/tauri.conf.json](mdc:src-tauri/tauri.conf.json) - App settings
- **Dependencies**: [src-tauri/Cargo.toml](mdc:src-tauri/Cargo.toml) - Rust dependencies

## Tauri Commands

### Command Structure
```rust
#[tauri::command]
async fn create_memo(title: String, content: String) -> Result<Memo, String> {
    // Command implementation
}
```

### Error Handling
```rust
#[tauri::command]
async fn save_memo(memo: Memo) -> Result<(), String> {
    match save_to_storage(&memo).await {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("Failed to save memo: {}", e))
    }
}
```

## Data Models

### Memo Structure
```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct Memo {
    pub id: String,
    pub title: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub tags: Vec<String>,
    pub is_pinned: bool,
}
```

### API Responses
```rust
#[derive(Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}
```

## Storage Implementation

### Local Storage
- **SQLite**: Use `rusqlite` for local database
- **File System**: Use `tokio::fs` for file operations
- **Preferences**: Use Tauri's built-in preferences API

### Database Schema
```sql
CREATE TABLE memos (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    tags TEXT,
    is_pinned BOOLEAN DEFAULT FALSE
);
```

## iOS Compatibility

### Platform-Specific Code
```rust
#[cfg(target_os = "ios")]
fn get_ios_specific_path() -> PathBuf {
    // iOS-specific implementation
}

#[cfg(not(target_os = "ios"))]
fn get_ios_specific_path() -> PathBuf {
    // Desktop implementation
}
```

### iOS Permissions
- **File Access**: Configure in [src-tauri/capabilities/default.json](mdc:src-tauri/capabilities/default.json)
- **Network**: Add network permissions if syncing with server
- **Storage**: Ensure proper storage permissions

## Security Considerations

### Input Validation
```rust
fn validate_memo_input(title: &str, content: &str) -> Result<(), String> {
    if title.trim().is_empty() {
        return Err("Title cannot be empty".to_string());
    }
    if content.len() > 100000 {
        return Err("Content too large".to_string());
    }
    Ok(())
}
```

### Data Sanitization
- Sanitize all user inputs
- Validate file paths and prevent directory traversal
- Use prepared statements for database queries

## Performance Optimization

### Async Operations
```rust
#[tauri::command]
async fn search_memos(query: String) -> Result<Vec<Memo>, String> {
    tokio::task::spawn_blocking(move || {
        // CPU-intensive search operation
    }).await.map_err(|e| e.to_string())?
}
```

### Memory Management
- Use `Arc<Mutex<>>` for shared state
- Implement proper cleanup in drop implementations
- Monitor memory usage on iOS

## Testing

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memo_creation() {
        let memo = Memo::new("Test", "Content");
        assert_eq!(memo.title, "Test");
    }
}
```

### Integration Tests
- Test Tauri commands end-to-end
- Mock file system operations
- Test iOS-specific functionality

## Dependencies to Add

### Essential Crates
```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
rusqlite = { version = "0.29", features = ["bundled"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

### Development Dependencies
```toml
[dev-dependencies]
tokio-test = "0.4"
mockall = "0.11"
```

## Common Patterns

### State Management
```rust
pub struct AppState {
    db: Arc<Mutex<Connection>>,
    config: Arc<RwLock<AppConfig>>,
}

#[tauri::command]
async fn get_memos(state: State<'_, AppState>) -> Result<Vec<Memo>, String> {
    let db = state.db.lock().await;
    // Database operations
}
```

### Event System
```rust
#[tauri::command]
async fn sync_memos(window: Window) -> Result<(), String> {
    // Sync operation
    window.emit("sync-progress", 50).unwrap();
    // More sync work
    window.emit("sync-complete", ()).unwrap();
    Ok(())
}
```

## Build Configuration

### iOS Build
- Use `cargo tauri build --target aarch64-apple-ios`
- Ensure all dependencies support iOS target
- Test on iOS simulator and device

### Debugging
- Use `println!` for debugging (will show in Tauri logs)
- Implement proper logging with `log` crate
- Use iOS console for device debugging